// Setup
void setup();

// Sensor reading
int sensorThresh = 50;
bool readR(); // Returns true if sensor is on black
bool readL();

// Motor control
void motorR(char power, bool dir = true);
void motorL(char power, bool dir = true);
void goStraight(char power, bool dir = true);
void turnR(char power);
void turnL(char power);

// Line following;
void followLine(char powerW, char powerB);
void followLineBack(char powerW, char powerB);

task main() {
    // Init of values
    int state = 0; // State for the state machine
    int counter1 = 0; // Counter value holder
    int commandI = 0; // Command iterator
    //int commandS = 32; // Command size
    //int commands[] = {2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3};
    int commandS = 2; // Command size
    int commands[] = {2, 4};
    
    // Speed control
    int maxSpeed = 100;
    int minSpeed = 10;
    
    // Extra control
    int turnCount = 500;
    int forwardCount = 150;
    
    // Commands
    // 2 = Follow line
    // 3 = Turn right
    // 4 = Turn left
    // 5 = Push can forward and go back
    
    while(true) {

        switch(state) {

                // Segment for setup
                case 0: // Setup state (Never go to this)
                        setup();
                        state = 1;
                        break;

                // Segment for processing commands
                case 1: // Command processor
                        goStraight(0); // Stop the motors
                        if (commandI < commandS) {
                            state = commands[commandI];
                            commandI++;
                        }
                        else {
                            //commandI = 0; // Repeat command set
                            Stop(true); // Stop when done with command set
                        }
                        break;

                // Segment for following a line
                case 2: // Follow line state
                        followLine(maxSpeed, minSpeed);
                        if (readR() && readL()) {
                            counter1 = forwardCount; // Used for the step
                            state = 21;
                        }
                        break;

                case 21: // Take small step forward
                        counter1 = counter1 - 1;
                        goStraight(maxSpeed);
                        if (counter1 < 1) {
                            state = 1;
                        }
                        break;
                        
                // Segment for turning right
                case 3: // Turn right
                        turnR(maxSpeed);
                        if (readR()) {
                            counter1 = turnCount;
                            state = 31;
                        }
                        break;
                        
                case 31: // Turn a bit more to position better
                        counter1 = counter1 - 1;
                        if (counter1 < 1) {
                            state = 1;
                        }
                        break;
                        
                // Segment for turning left
                case 4: // Turn left
                        turnL(maxSpeed);
                        if (readL()) {
                            counter1 = turnCount;
                            state = 31; // Reuse state since redundant
                        }
                        break;
                        
                // Segment for pushing can
                case 5: // Go forward
                        followLine(maxSpeed, minSpeed);
                        if (readR() && readL()) {
                            counter1 = forwardCount; // Used for the step
                            state = 51;
                        }
                        break;

                case 51: // Backup a bit
                        counter1 = counter1 - 1;
                        goStraight(maxSpeed, false);
                        if (counter1 < 1) {
                            state = 52;
                        }
                        break;
                        
                case 52: // Go backwards
                        followLineBack(maxSpeed, maxSpeed - 20);
                        if (readR() && readL()) {
                            counter1 = forwardCount; // Used for the step
                            state = 21; // reuse
                        }
                        break;


                // Stopping state for debugging
                case 987: // Stop
                        goStraight(0);
                        break;

                default:
                        // Do this when state is not found
                        break;
        }
    }
}

void setup() {
    // Set sensorR to be light sensor
    SetSensor(S1, SENSOR_NXTLIGHT);
    
    // Set sensorL to be light sensor
    SetSensor(S2, SENSOR_NXTLIGHT);
}

void followLine(char powerW, char powerB) {

        // motorR
        if (readR()) {
            motorR(powerB);
        }
        else {
            motorR(powerW);
        }

        // motorL
        if (readL()) {
            motorL(powerB);
        }
        else {
            motorL(powerW);
        }
        
}

void followLineBack(char powerW, char powerB) {

        // motorR
        if (readR()) {
            motorR(powerB, false);
        }
        else {
            motorR(powerW, false);
        }

        // motorL
        if (readL()) {
            motorL(powerB, false);
        }
        else {
            motorL(powerW, false);
        }

}

void motorR(char power, bool dir) {

    // Clamping value
    if (power > 100)
        power = 100;

    if (power < 0)
        power = 0;

    // Setting motor speed
    if (power == 0)
        Off(OUT_A);
    else if (dir == false)
        OnRev(OUT_A, power);
    else
        OnFwd(OUT_A, power);
}

void motorL(char power, bool dir) {

    // Clamping value
    if (power > 100)
        power = 100;

    if (power < 0)
        power = 0;

    // Setting motor speed
    if (power == 0)
        Off(OUT_B);
    else if (dir == false)
        OnRev(OUT_B, power);
    else
        OnFwd(OUT_B, power);
}

void goStraight(char power, bool dir) {
    if (dir == true) {
        motorR(power);
        motorL(power);
    } else {
        motorR(power, false);
        motorL(power, false);
    }
    
}

void turnR(char power) {
    motorR(power, false);
    motorL(power);
}

void turnL(char power) {
    motorR(power);
    motorL(power, false);
}

bool readR() {
    int value = Sensor(S1);

    if (value > sensorThresh)
        return false;
    return true;
}

bool readL() {
    int value = Sensor(S2);

    if (value > sensorThresh)
        return false;
    return true;
}
